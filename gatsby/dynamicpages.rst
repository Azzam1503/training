Dynamic pages
=============

In previous chapters, we learned how:

- create static pages
- fetch data
- query data and show it in pages

We could potentially build our static websites just with these informations.
The only problem is that we need to manually create every single page that we need.

The last missing part in building a static website with GatsbyJS is to programmatically generate these pages from data.

As we've seen in the `pages` chapter, at build time Gatsby maps every page with an URL that is its filename.
If we want to programmatically generate static pages, we're not going to have different page components, but only GraphQL nodes, so we need to provide some additional informations in nodes.
In particular we need to add a "slug" or "path" attribute to the node.

.. note:: most source plugins automatically add this information in nodes, for example cms plugins.

GatsbyJS building stack has a series of steps that perform different actions sequentially:

- read configuration, to load the list of plugins
- initialize the cache (to avoid re-fetch untouched data)
- pull the data and preprocess it in a GraphQL schema
- create pages (from `/pages` folder or from plugins)
- extract and run GraphQL queries and replace their values in pages
- write out the pages

Gatsby provides also a rich set of lifecycle APIs to hook into every step and perform some customizations.

In this chapter we're going to use two of them, that are the most used in plugins:

- `onCreateNode`: called by Gatsby whenever a node is created or updated, so we can edit the current node before storing it into GraphQL
- `createPages`: step that creates a page.

To implement an API, we need to export a function with the same name of the API in a file called `gatsby-node.js`.

Let's start with the first one, and export a function called `onCreateNode`:

.. code.block:: none

  exports.onCreateNode = ({ node }) => {
    console.log(node.internal.type)
  }

This function is called whenever a node is created, so if we restart the server now, we'll see that in the console we'll have the types of every node.
But we want to add a slug only for our blogposts that are generated by MarkdownRemark plugin, so we need to filter them by type.

To generate the slug for this node, we could use an helper funcion from `gatsby-source-filesystem` that is made for this purpose (if you remember, remark nodes are built on top of filesystem nodes).

The last thing that we need to do, is to add the slug attribute to the node. Nodes can be directly modified only by the plugins that creats them. Other plugins can add new fields to the nodes only with a specific function called `createNodeField` (for security reasons).

And finally, our `onCreateNode` function will be similar to this:

.. code.block:: none

  const { createFilePath } = require(`gatsby-source-filesystem`)

  exports.onCreateNode = ({ node, getNode, actions }) => {
    const { createNodeField } = actions
    if (node.internal.type === `MarkdownRemark`) {
      const slug = createFilePath({ node, getNode, basePath: `pages` })
      createNodeField({
        node,
        name: `slug`,
        value: slug,
      })
    }
  }

If we restart the server and try to query the data, we'll see the slug under the `fields` attribute.

