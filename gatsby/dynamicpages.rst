Dynamic pages
=============

In previous chapters, we learned how:

- Create static pages
- Fetch data from external sources
- Query data and show it in pages

We could potentially build our static websites just with these informations.

The only problem is that we need to manually create every single page that we need.

The last missing part in building a static website with GatsbyJS is to programmatically generate these pages from data.

As we have seen in the `pages` chapter, at build time GatsbyJS maps every page with an URL that is its filename.

If we want to programmatically generate static pages, we are not going to have different page components (one for each node), but only GraphQL nodes, so we need to provide some additional informations in nodes to allow GatsbyJS to generate the correct pages and urls.

In particular we need to add a "slug" or "path" attribute to the node.

.. note:: A lot of source plugins automatically add this information in nodes, like CMS plugins.

GatsbyJS building stack has a series of steps that performs different actions sequentially:

- Read the configuration to load the list of plugins
- Initialize the cache (to avoid re-fetch untouched data)
- Pull the data and preprocess it in a GraphQL schema
- Create pages (from `/pages` folder or from plugins)
- Extract and run GraphQL queries and replace their values in pages
- Write out the pages as static HTML pages

GatsbyJS provides a rich set of lifecycle APIs to hook into every step and perform some customizations.

In this chapter we are going to use two of them, that are the most used in plugins:

- `onCreateNode`: called by Gatsby whenever a node is created or updated, so we can edit the current node before storing it into GraphQL
- `createPages`: step that creates a page.

To implement an API, we need to export a function with the same name of the API in a file called `gatsby-node.js`.

Let's start with the first one, and export a function called `onCreateNode`:

.. code-block:: none

  exports.onCreateNode = ({ node }) => {
    console.log(node.internal.type)
  }

This function is called whenever a node is created, so if we restart the server now, we will see in the console a list of node types.

But we want to add a slug only for blogposts that are generated by MarkdownRemark plugin, so we need to filter them by type.

To generate the slug for this node, we could use an helper function from `gatsby-source-filesystem` that is made for this purpose (if you remember, remark nodes are built on top of filesystem nodes).

The last thing that we need to do, is to add the slug attribute to the node.

Nodes can be directly modified only by the plugins that creats them. Other plugins can add new fields to the nodes only with a specific function called `createNodeField` (for security reasons).

And finally, our `onCreateNode` function will be similar to this:

.. code-block:: none

  const { createFilePath } = require(`gatsby-source-filesystem`)

  exports.onCreateNode = ({ node, getNode, actions }) => {
    const { createNodeField } = actions
    if (node.internal.type === `MarkdownRemark`) {
      const slug = createFilePath({ node, getNode, basePath: `blog` })
      createNodeField({
        node,
        name: `slug`,
        value: slug,
      })
    }
  }

If we restart the server and try to query the data, we'll see the slug under the `fields` attribute.

Now that we have all the informations, we need to create pages.

As mentioned in the introduction, to create a page, we need to query data with GraphQL and then map the results into a page.
So we need to export the `createPage` function as follows:

.. code-block:: none

  ...
  const path = require(`path`)
  ...

  exports.createPages = ({ graphql, actions }) => {
    const { createPage } = actions
    return new Promise((resolve, reject) => {
      graphql(`
        {
          allMarkdownRemark {
            edges {
              node {
                fields {
                  slug
                }
              }
            }
          }
        }
      `).then(result => {
        result.data.allMarkdownRemark.edges.forEach(({ node }) => {
          createPage({
            path: node.fields.slug,
            component: path.resolve(`./src/templates/blog-post.js`),
            context: {
              slug: node.fields.slug,
            },
          })
        })
        resolve()
      })
    })
  }

What can we see here?

First of all we perform a GraphQL query, and iterate through results to create a new page.

The method `createPage` is an helper method that Gatsby uses to generate dynamic pages. It takes 3 parameters:

- `path`: the slug value. This is used to generate the url where we can access the current page
- `component`: is the template used to populate a blog post page. It is similar to a page component (we will see it shortly)
- `context`: we can pass a list of variables that can be used by the queries into page components (not StaticQuery) to fetch infos about the current node.

A this point we just have to create the `blog-post.js` template file to end our setup:

.. code-block:: none

  import React from "react"
  import { graphql } from "gatsby"
  import Layout from '../components/layout'

  export default ({ data }) => {
    const post = data.markdownRemark
    return (
      <Layout>
        <div>
          <h1>{post.frontmatter.title}</h1>
          <div dangerouslySetInnerHTML={{ __html: post.html }} />
        </div>
      </Layout>
    )
  }

  export const query = graphql`
    query($slug: String!) {
      markdownRemark(fields: { slug: { eq: $slug } }) {
        html
        frontmatter {
          title
        }
      }
    }
  `

This is similar to a simple page component, except for GraphQL query: we need to fetch data for a specific node. To do this, we can use the `slug` value to filter only desired node.

.. note:: We can filter with almost every node attribute, but it is always better use unique values like id or the slug.

.. note:: `dangerouslySetInnerHTML` is an helper function of ReactJS that allows to insert some not-reactish html into a component.

If we restart the server, we could now access directly to the pages created automatically.

.. note:: To easily get a list of generated urls, try to access to a random page like http://localhost:8000/asdf. The default NotFound page will propose you some possible alternative urls.

Last thing that we could do, is to link them in our index.js page:

.. code-block:: none

  ...
  <Link to={node.fields.slug}>
    <h3>
      {node.frontmatter.title}{" "}
      <span>
        â€” {node.frontmatter.date}
      </span>
    </h3>
  </Link>