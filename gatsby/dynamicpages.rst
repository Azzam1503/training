Dynamic pages
=============

In previous chapters, we learned how:

- create static pages
- fetch data
- query data and show it in pages

We could potentially build our static websites just with these informations.
The only problem is that we need to manually create every single page that we need.

The last missing part in building a static website with GatsbyJS is to programmatically generate these pages from data.

As we've seen in the `pages` chapter, at build time Gatsby maps every page with an URL that is its filename.
If we want to programmatically generate static pages, we're not going to have different page components, but only GraphQL nodes, so we need to provide some additional informations in nodes.
In particular we need to add a "slug" or "path" attribute to the node.

.. note:: most source plugins automatically add this information in nodes, for example cms plugins.

GatsbyJS building stack has a series of steps that perform different actions sequentially:

- read configuration, to load the list of plugins
- initialize the cache (to avoid re-fetch untouched data)
- pull the data and preprocess it in a GraphQL schema
- create pages (from `/pages` folder or from plugins)
- extract and run GraphQL queries and replace their values in pages
- write out the pages

Gatsby provides also a rich set of lifecycle APIs to hook into every step and perform some customizations.

In this chapter we're going to use two of them, that are the most used in plugins:

- `onCreateNode`: called by Gatsby whenever a node is created or updated, so we can edit the current node before storing it into GraphQL
- `createPages`: step that creates a page.

To implement an API, we need to export a function with the same name of the API in a file called `gatsby-node.js`.

Let's start with the first one, and export a function called `onCreateNode`:

.. code-block:: none

  exports.onCreateNode = ({ node }) => {
    console.log(node.internal.type)
  }

This function is called whenever a node is created, so if we restart the server now, we'll see that in the console we'll have the types of every node.
But we want to add a slug only for our blogposts that are generated by MarkdownRemark plugin, so we need to filter them by type.

To generate the slug for this node, we could use an helper funcion from `gatsby-source-filesystem` that is made for this purpose (if you remember, remark nodes are built on top of filesystem nodes).

The last thing that we need to do, is to add the slug attribute to the node. Nodes can be directly modified only by the plugins that creats them. Other plugins can add new fields to the nodes only with a specific function called `createNodeField` (for security reasons).

And finally, our `onCreateNode` function will be similar to this:

.. code-block:: none

  const { createFilePath } = require(`gatsby-source-filesystem`)

  exports.onCreateNode = ({ node, getNode, actions }) => {
    const { createNodeField } = actions
    if (node.internal.type === `MarkdownRemark`) {
      const slug = createFilePath({ node, getNode, basePath: `blog` })
      createNodeField({
        node,
        name: `slug`,
        value: slug,
      })
    }
  }

If we restart the server and try to query the data, we'll see the slug under the `fields` attribute.

Now that we have all the informations, we need to create pages.

As mentioned in the intro, to create a page, we need to query data with GraphQL and then map the results into a page.
So we need to export the `createPage` function as follows:

.. code-block:: none

  ...
  const path = require(`path`)
  ...

  exports.createPages = ({ graphql, actions }) => {
    const { createPage } = actions
    return new Promise((resolve, reject) => {
      graphql(`
        {
          allMarkdownRemark {
            edges {
              node {
                fields {
                  slug
                }
              }
            }
          }
        }
      `).then(result => {
        result.data.allMarkdownRemark.edges.forEach(({ node }) => {
          createPage({
            path: node.fields.slug,
            component: path.resolve(`./src/templates/blog-post.js`),
            context: {
              slug: node.fields.slug,
            },
          })
        })
        resolve()
      })
    })
  }

What can we see here?

First of all we perform a GraphQL query, and we iterate through results to create a new page.

The method `createPage` is an helper method that Gatsby uses to generate dynamic pages. It takes 3 parameters:

- `path`: the slug value. This is used to generate the url where we can access the current page
- `component`: is the template used to populate a blog post page. It's similar to a page component (we will see it shortly)
- `context`: we can pass a list of variables that can be used by the component's queries to fetch infos about the current node.

A this point we just have to create the `blog-post.js` template file to end our setup:

.. code-block:: none

  import React from "react"
  import { graphql } from "gatsby"

  export default ({ data }) => {
    const post = data.markdownRemark
    return (
      <div>
        <h1>{post.frontmatter.title}</h1>
        <div dangerouslySetInnerHTML={{ __html: post.html }} />
      </div>
    )
  }

  export const query = graphql`
    query($slug: String!) {
      markdownRemark(fields: { slug: { eq: $slug } }) {
        html
        frontmatter {
          title
        }
      }
    }
  `

As you can see, it's similar to a simple page, with the only difference in GraphQL query: we need to fetch data from a specific node. To do this, we can use the `slug` value to filter only desired node.

.. note:: we can filter with almost every node attribute, but it's always better use uniques values like some id or the slug.

.. note:: `dangerouslySetInnerHTML` is an helper function of ReactJS that allows to insert some not-reactish html into a component.

If we restart the server, we could now access directly to the new pages created automatically.

.. note:: to easily get a list of generated urls, try to access to a random page like http://localhost:8000/asdf . The default 404 page will propose you possible alternative urls.

Last thing that we could do, is to link them in our index.js page:

.. code-block:: none

  ...
  <Link to={node.fields.slug}>
    <h3>
      {node.frontmatter.title}{" "}
      <span>
        â€” {node.frontmatter.date}
      </span>
    </h3>
  </Link>